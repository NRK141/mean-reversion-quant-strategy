# -*- coding: utf-8 -*-
"""Mean Reversion Strategy (Z-Scores).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HmPVmYUtQrLwt0Ua5yOZqs-iyLfcDu8U
"""

!pip install yfinance pandas numpy matplotlib seaborn
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

# =============================
# STRATEGY PARAMETERS
# =============================
START_YEAR = 2023

INITIAL_CAPITAL = 10_000
MAX_POSITION_DOLLARS = 2_500

RET_LEN = 2
MEAN_LEN = 25
Z_THRESHOLD = 0.75
Z_EXIT_THRESHOLD = 0.5  # kept but not used (commented in Pine)
STOP_PCT = .03
TAKE_PCT = 0.07

# ============= TICKERS =================
TICKERS = ["GOOG", "GILD", "MPWR",  "MSFT", "CEG"]

# =============================
# HELPER FUNCTIONS
# =============================
def qty_calc(price):
    price = float(price)
    return int(MAX_POSITION_DOLLARS // price)

def compute_zscore(df):
    df["ret"] = df["Close"] / df["Close"].shift(RET_LEN) - 1
    df["ret_mean"] = df["ret"].rolling(MEAN_LEN).mean()
    df["ret_std"] = df["ret"].rolling(MEAN_LEN).std()
    df["zscore"] = (df["ret"] - df["ret_mean"]) / df["ret_std"]
    return df

#============== Load & Align Market Data (Critical for Shared Capital) ================
data = {}

for t in TICKERS:
    df = yf.download(t, start=f"{START_YEAR}-01-01", auto_adjust=True)
    df = compute_zscore(df)
    data[t] = df

# =============================
# BUILD PRICE & Z-SCORE MATRICES (SAFE ALIGNMENT)
# =============================

prices = pd.concat(
    {t: data[t]["Close"] for t in TICKERS},
    axis=1
)

zscores = pd.concat(
    {t: data[t]["zscore"] for t in TICKERS},
    axis=1
)

# Ensure identical index across both
common_index = prices.index.intersection(zscores.index)

prices = prices.loc[common_index].dropna(how="any")
zscores = zscores.loc[prices.index]

# =======================================================================================
#                             SHARED-CAPITAL BACKTEST ENGINE
# =======================================================================================

cash = float(INITIAL_CAPITAL)
positions = {}
trade_log = []
equity_curve = []

# Ensure clean index
prices = prices[~prices.index.duplicated()]
zscores = zscores.loc[prices.index]

for date in prices.index:

    # =============================
    # EXIT LOGIC (TP / SL FIRST)
    # =============================
    for ticker in list(positions.keys()):

        price = prices.loc[date, ticker]
        z = zscores.loc[date, ticker]

        # Force scalar
        if isinstance(price, (pd.Series, np.ndarray)):
            price = float(price.iloc[0])
        if isinstance(z, (pd.Series, np.ndarray)):
            z = float(z.iloc[0])

        if pd.isna(price):
            continue

        pos = positions[ticker]

        stop_price = pos["entry_price"] * (1 - STOP_PCT)
        take_price = pos["entry_price"] * (1 + TAKE_PCT)

        if price <= stop_price or price >= take_price:
            proceeds = pos["shares"] * price
            pnl = proceeds - pos["cost"]

            cash += proceeds

            trade_log.append({
                "Ticker": ticker,
                "Entry Date": pos["entry_date"],
                "Exit Date": date,
                "Return %": (pnl / pos["cost"]) * 100
            })

            del positions[ticker]

    # =============================
    # ENTRY LOGIC (LONG ONLY)
    # =============================
    for ticker in TICKERS:
        if ticker in positions:
            continue

        price = prices.loc[date, ticker]
        z = zscores.loc[date, ticker]

        # Force scalar
        if isinstance(price, (pd.Series, np.ndarray)):
            price = float(price.iloc[0])
        if isinstance(z, (pd.Series, np.ndarray)):
            z = float(z.iloc[0])

        if pd.isna(price) or pd.isna(z):
            continue

        if z < -Z_THRESHOLD:
            qty = qty_calc(price)
            cost = qty * price

            if qty > 0 and cash >= cost:
                cash -= cost
                positions[ticker] = {
                    "entry_price": price,
                    "shares": qty,
                    "cost": cost,
                    "entry_date": date
                }

    # =============================
    # DAILY MARK-TO-MARKET
    # =============================
    open_value = 0.0
    for t, pos in positions.items():
        px = prices.loc[date, t]

        if isinstance(px, (pd.Series, np.ndarray)):
            px = float(px.iloc[0])

        if not pd.isna(px):
            open_value += pos["shares"] * px

    equity_curve.append({
        "Date": date,
        "Equity": cash + open_value
    })

#====================== COMBINED PORTFOLIO & TICKER DASHBOARD =============================

import seaborn as sns
sns.set(style="whitegrid")

# ----------------------
# Prepare trades dataframe
# ----------------------
trades_df = pd.DataFrame(trade_log)

# Ensure PnL column exists
if 'PnL' not in trades_df.columns:
    trades_df['PnL'] = (trades_df['Return %'] / 100) * INITIAL_CAPITAL  # rough approx

# Portfolio equity dataframe
equity_df = pd.DataFrame(equity_curve).set_index("Date")

# ----------------------
# Portfolio Metrics
# ----------------------
# Daily returns
returns = equity_df["Equity"].pct_change().dropna()
sharpe = np.sqrt(252) * returns.mean() / returns.std() if returns.std() != 0 else 0

# Drawdown & Max Drawdown
rolling_max = equity_df["Equity"].cummax()
drawdown = (equity_df["Equity"] - rolling_max) / rolling_max
max_dd = drawdown.min()

# CAGR & Calmar Ratio
cagr = (equity_df["Equity"].iloc[-1] / equity_df["Equity"].iloc[0]) ** (252 / len(equity_df)) - 1
calmar = cagr / abs(max_dd) if max_dd != 0 else np.nan

# Trade-based metrics
total_trades = len(trades_df)
winning_trades = trades_df[trades_df['PnL'] > 0]
losing_trades = trades_df[trades_df['PnL'] <= 0]
winning_pct = len(winning_trades) / total_trades * 100 if total_trades > 0 else 0
losing_pct = 100 - winning_pct
avg_win = winning_trades['PnL'].mean() if len(winning_trades) > 0 else 0
avg_loss = losing_trades['PnL'].mean() if len(losing_trades) > 0 else 0
profit_factor = abs(winning_trades['PnL'].sum() / losing_trades['PnL'].sum()) if len(losing_trades) > 0 else np.nan
largest_win = winning_trades['PnL'].max() if len(winning_trades) > 0 else 0
largest_loss = losing_trades['PnL'].min() if len(losing_trades) > 0 else 0
avg_trade = trades_df['PnL'].mean() if total_trades > 0 else 0

# Metrics DataFrame
metrics = pd.DataFrame({
    "Metric": [
        "Initial Capital", "Final Equity", "CAGR (%)", "Sharpe Ratio", "Calmar Ratio", "Max Drawdown (%)",
        "Total Trades", "Winning %", "Avg Winning Trade", "Avg Losing Trade", "Avg Trade PnL",
        "Largest Win", "Largest Loss", "Profit Factor"
    ],
    "Value": [
        INITIAL_CAPITAL, equity_df["Equity"].iloc[-1], cagr*100, sharpe, calmar, max_dd*100,
        total_trades, winning_pct, avg_win, avg_loss, avg_trade,
        largest_win, largest_loss, profit_factor
    ]
})

print("===== PORTFOLIO METRICS =====")
print(metrics)

# ----------------------
# Ticker-level metrics
# ----------------------
ticker_stats = trades_df.groupby("Ticker")["Return %"].agg(["count","mean","sum"]).reset_index()
print("\n===== TICKER METRICS =====")
print(ticker_stats)

# ----------------------
# Visualization
# ----------------------
fig, axs = plt.subplots(2, 2, figsize=(16,10))

# 1️⃣ Portfolio Equity Curve
axs[0,0].plot(equity_df.index, equity_df["Equity"], color='blue', linewidth=2)
axs[0,0].axhline(INITIAL_CAPITAL, linestyle='--', color='k', alpha=0.7)
axs[0,0].set_title("Portfolio Equity Curve")
axs[0,0].set_ylabel("Equity ($)")
axs[0,0].grid(True)

# 2️⃣ Portfolio Drawdown
axs[0,1].plot(drawdown.index, drawdown*100, color='red', linewidth=2)
axs[0,1].axhline(0, color='k', linestyle='--')
axs[0,1].set_title("Portfolio Drawdown (%)")
axs[0,1].set_ylabel("Drawdown %")
axs[0,1].grid(True)

# 3️⃣ Trade PnL Distribution
sns.histplot(trades_df['PnL'], bins=30, kde=True, ax=axs[1,0], color='skyblue')
axs[1,0].axvline(trades_df['PnL'].mean(), color='r', linestyle='-', label='Mean')
axs[1,0].axvline(trades_df['PnL'].median(), color='g', linestyle='--', label='Median')
axs[1,0].set_title("Trade PnL Distribution")
axs[1,0].set_xlabel("PnL ($)")
axs[1,0].set_ylabel("Frequency")
axs[1,0].legend()

# 4️⃣ Per-Ticker Cumulative PnL
for ticker in TICKERS:
    ticker_trades = trades_df[trades_df['Ticker']==ticker]
    cumulative = ticker_trades['PnL'].cumsum()
    axs[1,1].plot(cumulative.index, cumulative, label=ticker)
axs[1,1].set_title("Per-Ticker Cumulative PnL")
axs[1,1].set_ylabel("Cumulative PnL ($)")
axs[1,1].legend()
axs[1,1].grid(True)

plt.tight_layout()
plt.show()