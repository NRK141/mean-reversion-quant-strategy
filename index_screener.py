# -*- coding: utf-8 -*-
"""Index Screener.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1It9K8BBpxMIs6fW615Ngd6Vta8LMJxya
"""

#====================== STOCK SCREENING FOR Z-SCORE STRATEGY ======================

!pip install yfinance pandas numpy

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# ===========================
# SECTION 1: STOCK UNIVERSE (FINAL, FIXED)
# ===========================

import pandas as pd
import requests
from io import StringIO

# -------------------------------------------------
# USER SELECTION
# -------------------------------------------------
SELECTED_INDEX = "SP500"
# OPTIONS:
# "SP500"
# "NASDAQ100"
# "DOWJONES"

HEADERS = {
    "User-Agent": "Mozilla/5.0"
}

# -------------------------------------------------
# WIKI TABLE READER (403 SAFE)
# -------------------------------------------------
def read_wiki_table(url, table_index):
    html = requests.get(url, headers=HEADERS, timeout=20).text
    return pd.read_html(StringIO(html))[table_index]


# -------------------------------------------------
# INDEX LOADERS (WORKING)
# -------------------------------------------------
def load_sp500():
    df = read_wiki_table(
        "https://en.wikipedia.org/wiki/List_of_S%26P_500_companies", 0
    )
    return df["Symbol"].astype(str).str.upper().tolist()


def load_nasdaq100():
    df = read_wiki_table(
        "https://en.wikipedia.org/wiki/NASDAQ-100", 4
    )
    return df["Ticker"].astype(str).str.upper().tolist()


def load_dowjones():
    df = read_wiki_table(
        "https://en.wikipedia.org/wiki/Dow_Jones_Industrial_Average", 1
    )
    return df["Symbol"].astype(str).str.upper().tolist()


# -------------------------------------------------
# RUSSELL INDEXES (NON-WIKI, REAL TICKERS)
# -------------------------------------------------
def load_russell1000():
    url = "https://ftp.nasdaqtrader.com/dynamic/SymDir/russell1000.txt"
    df = pd.read_csv(url, sep="|")
    return df["Symbol"].dropna().astype(str).str.upper().tolist()


def load_russell2000():
    url = "https://ftp.nasdaqtrader.com/dynamic/SymDir/russell2000.txt"
    df = pd.read_csv(url, sep="|")
    return df["Symbol"].dropna().astype(str).str.upper().tolist()


# -------------------------------------------------
# DISPATCHER
# -------------------------------------------------
def load_index_tickers(index_name):
    loaders = {
        "SP500": load_sp500,
        "NASDAQ100": load_nasdaq100,
        "DOWJONES": load_dowjones,
        "RUSSELL1000": load_russell1000,
        "RUSSELL2000": load_russell2000,
    }

    try:
        tickers = loaders[index_name]()
        tickers = list(set(tickers))
        tickers = [t for t in tickers if t.isalpha()]

        return tickers

    except Exception as e:
        print(f"[ERROR] Failed loading {index_name}: {e}")
        return []


# -------------------------------------------------
# LOAD UNIVERSE
# -------------------------------------------------
tickers = load_index_tickers(SELECTED_INDEX)

print(f"{SELECTED_INDEX} loaded: {len(tickers)} tickers")
print("Sample tickers:", tickers[:20])

# ===========================
# SECTION 2: STRATEGY PARAMETERS
# ===========================
START_YEAR = 2020
RET_LEN = 2
MEAN_LEN = 25
Z_THRESHOLD = 0.75
MAX_POSITION_DOLLARS = 2500

# -------------------------
# HELPER FUNCTIONS
# -------------------------

def compute_zscore(df, ret_len=1, mean_len=10):
    """
    Compute rolling z-score for stock returns.
    Returns the DataFrame with a new 'zscore' column.
    """
    df = df.copy()
    close = df['Close']  # ensure we have a Series
    returns = close.pct_change(ret_len)

    rolling_mean = returns.rolling(mean_len).mean()
    rolling_std = returns.rolling(mean_len).std()

    zscore = (returns - rolling_mean) / rolling_std
    df['zscore'] = zscore.fillna(0)

    return df

def calculate_shares(price, max_position_dollars):
    if price <= 0: return 0
    return max(int(max_position_dollars // price), 0)


def backtest_stock(df,
                   initial_capital=10000,
                   max_position_dollars=2500,
                   ret_len=2,
                   mean_len=25,
                   z_threshold=0.5):

    # ==============================
    # HARD DATA SANITIZATION
    # ==============================
    df = df.copy()

    # Flatten MultiIndex
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)

    # Force Close to 1D numpy array
    close = df['Close'].values.astype(float)
    dates = df.index.values

    if len(close) < mean_len + ret_len:
        return None  # not enough data

    # ==============================
    # Z-SCORE (PURE NUMPY)
    # ==============================
    returns = np.zeros_like(close)
    returns[ret_len:] = close[ret_len:] / close[:-ret_len] - 1

    zscore = np.full_like(close, np.nan)

    for i in range(mean_len + ret_len, len(close)):
        window = returns[i - mean_len:i]
        std = window.std()
        if std > 0:
            zscore[i] = (returns[i] - window.mean()) / std

    # ==============================
    # STATE
    # ==============================
    capital = float(initial_capital)
    position = 0
    entry_price = 0.0

    equity_curve = []
    trades = []

    # ==============================
    # BACKTEST LOOP (SCALAR SAFE)
    # ==============================
    for i in range(len(close)):
        price = float(close[i])
        z = zscore[i]
        date = dates[i]

        if np.isnan(z):
            equity_curve.append({'Date': date, 'Equity': capital})
            continue

        # ---------- ENTRY ----------
        if position == 0 and z < -z_threshold:
            qty = int(min(max_position_dollars / price, capital / price))

            if qty > 0:
                capital -= qty * price
                position = qty
                entry_price = price

                trades.append({
                    'Date': date,
                    'Type': 'BUY',
                    'Price': price,
                    'Qty': qty
                })

        # ---------- EXIT ----------
        elif position > 0 and z >= 0:
            proceeds = position * price
            pnl = proceeds - (position * entry_price)
            capital += proceeds

            trades.append({
                'Date': date,
                'Type': 'SELL',
                'Price': price,
                'Qty': position,
                'PnL': pnl
            })

            position = 0
            entry_price = 0.0

        equity = capital + position * price
        equity_curve.append({'Date': date, 'Equity': equity})

    equity_df = pd.DataFrame(equity_curve).set_index('Date')

    # ==============================
    # METRICS
    # ==============================
    rets = equity_df['Equity'].pct_change().fillna(0)

    sharpe = (rets.mean() / rets.std() * np.sqrt(252)) if rets.std() > 0 else 0
    years = len(equity_df) / 252
    cagr = (equity_df['Equity'].iloc[-1] / equity_df['Equity'].iloc[0]) ** (1 / years) - 1 if years > 0 else 0
    drawdown = equity_df['Equity'] / equity_df['Equity'].cummax() - 1

    return {
        "Equity Curve": equity_df,
        "Trades": trades,
        "Num Trades": len(trades) // 2,
        "Sharpe": sharpe,
        "CAGR": cagr,
        "Max Drawdown": drawdown.min()
    }

# ===========================
# SECTION 4: TICKER LOOPING & CALCS (CORRECTED)
# ===========================

downloaded_tickers = []
traded_tickers = []
results = []

for t in tickers:
    try:
        df = yf.download(
            t,
            start=f"{START_YEAR}-01-01",
            auto_adjust=True,
            progress=False
        )

        if df.empty:
            continue

        downloaded_tickers.append(t)

        metrics = backtest_stock(df)

        if metrics is None:
            continue

        if metrics["Num Trades"] > 0:
            traded_tickers.append(t)

            results.append({
                "Ticker": t,
                "Sharpe": metrics["Sharpe"],
                "CAGR": metrics["CAGR"],
                "Max Drawdown": metrics["Max Drawdown"],
                "Num Trades": metrics["Num Trades"]
            })

    except Exception as e:
        print(f"Skipped {t} due to error: {e}")

# ===========================
# Summary Output
# ===========================
print(f"\nSuccessfully downloaded tickers ({len(downloaded_tickers)}):")
print(downloaded_tickers[:20], "...")

print(f"\nTickers that executed trades ({len(traded_tickers)}):")
print(traded_tickers[:20], "...")

# ===========================
# RANKING, FILTERING & COMPOSITE SCORE
# ===========================

import numpy as np
import pandas as pd

if len(results) == 0:
    print("No stocks generated trades. Adjust filters or strategy parameters.")
else:
    results_df = pd.DataFrame(results)

    # ---------------------------
    # SAFETY CHECKS
    # ---------------------------
    required_cols = ["Ticker", "Sharpe", "CAGR", "Max Drawdown", "Num Trades"]
    missing = [c for c in required_cols if c not in results_df.columns]

    if missing:
        raise ValueError(f"Missing required columns: {missing}")

    # ---------------------------
    # CREATE CALMAR FIRST
    # ---------------------------
    results_df["Calmar"] = np.where(
        results_df["Max Drawdown"].abs() > 0,
        results_df["CAGR"] / results_df["Max Drawdown"].abs(),
        np.nan
    )

    # ---------------------------
    # DROP INVALID ROWS
    # ---------------------------
    results_df = results_df.dropna(
        subset=["Sharpe", "CAGR", "Calmar", "Num Trades"]
    )

    # ---------------------------
    # HARD FILTERS (YOUR RULES)
    # ---------------------------
    filtered_df = results_df[
        (results_df["Sharpe"] > 0.85) &
        (results_df["Calmar"] > 0) &
        (results_df["CAGR"] > 0.0) &
        (results_df["Num Trades"] > 100)
    ].copy()

    if filtered_df.empty:
        print("No stocks passed the hard filters.")
    else:
        print(f"\nStocks passing filters: {len(filtered_df)}\n")

        # ---------------------------
        # NORMALIZATION (0â€“1)
        # ---------------------------
        def normalize(series):
            return (series - series.min()) / (series.max() - series.min())

        filtered_df["Sharpe_norm"] = normalize(filtered_df["Sharpe"])
        filtered_df["Calmar_norm"] = normalize(filtered_df["Calmar"])
        filtered_df["CAGR_norm"] = normalize(filtered_df["CAGR"])
        filtered_df["Trades_norm"] = normalize(filtered_df["Num Trades"])

        # ---------------------------
        # COMPOSITE SCORE
        # ---------------------------
        WEIGHTS = {
            "Sharpe": 0.30,
            "Calmar": 0.30,
            "CAGR": 0.30,
            "Trades": 0.10
        }

        filtered_df["Composite Score"] = (
            filtered_df["Sharpe_norm"] * WEIGHTS["Sharpe"] +
            filtered_df["Calmar_norm"] * WEIGHTS["Calmar"] +
            filtered_df["CAGR_norm"] * WEIGHTS["CAGR"] +
            filtered_df["Trades_norm"] * WEIGHTS["Trades"]
        )

        # ---------------------------
        # COMPOSITE RANKING
        # ---------------------------
        composite_ranked = filtered_df.sort_values(
            "Composite Score", ascending=False
        ).reset_index(drop=True)

        print("=== TOP STOCKS (COMPOSITE RANKING) ===")
        print(
            composite_ranked[
                ["Ticker", "Composite Score", "Sharpe", "Calmar", "CAGR", "Num Trades"]
            ].head(20)
        )

        print("\n")

        # ---------------------------
        # SHARPE RANKING
        # ---------------------------
        print("=== TOP STOCKS (SHARPE) ===")
        print(
            filtered_df.sort_values("Sharpe", ascending=False)[
                ["Ticker", "Sharpe", "Calmar", "CAGR", "Num Trades"]
            ].head(20)
        )

        print("\n")

        # ---------------------------
        # CAGR RANKING
        # ---------------------------
        print("=== TOP STOCKS (CAGR) ===")
        print(
            filtered_df.sort_values("CAGR", ascending=False)[
                ["Ticker", "CAGR", "Sharpe", "Calmar", "Num Trades"]
            ].head(20)
        )